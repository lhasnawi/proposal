//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

#include <P3DModuleDB.h>

namespace queueing {

P3DModuleDB::P3DModuleDB() {
    // TODO Auto-generated constructor stub

}

P3DModuleDB::~P3DModuleDB() {
    // TODO Auto-generated destructor stub
}



int P3DModuleDB::getContOutputPortId() const {
    return contOutputPortID;
}

void P3DModuleDB::setContOutputPortId(int contOutputPortId) {
    contOutputPortID = contOutputPortId;
}

int P3DModuleDB::getModuleId() const {
    return moduleID;
}

void P3DModuleDB::setModuleId(int moduleId) {
    moduleID = moduleId;
}

string P3DModuleDB::getModuleName() const {
    return moduleName;
}

void P3DModuleDB::setModuleName(string moduleName) {
    this->moduleName = moduleName;
}

int P3DModuleDB::getModuleType() const {
    return moduleType;
}

void P3DModuleDB::setModuleType(int moduleType) {
    this->moduleType = moduleType;
}

bool P3DModuleDB::isBarState() const {
    return barState;
}

void P3DModuleDB::setBarState(bool barState) {
    this->barState = barState;
}

bool P3DModuleDB::isBusy() const {
    return busy;
}

int P3DModuleDB::getDelay() const {
    return delay;
}

void P3DModuleDB::setDelay(int delay) {
    this->delay = delay;
}


const cQueue& P3DModuleDB::getSwitchingContQ() const {
    return SwitchingContQ;
}

void P3DModuleDB::setSwitchingContQ(const cQueue& switchingContQ) {
    SwitchingContQ = switchingContQ;
}

void P3DModuleDB::setBusy(bool busy) {
    this->busy = busy;
}

void P3DModuleDB::insertOrderedSWC(SSSwitchingCont * sw)
{}


int P3DModuleDB::getQueueLength() {
    return this->SwitchingContQ.getLength();
}

void P3DModuleDB::printSwitcchingContQ() {
    cQueue::Iterator currentIter =  cQueue::Iterator ( this->SwitchingContQ, 0);
    SSSwitchingCont * SWC;
    int counter=0;
    EV<<"=============================="<<endl;
    EV<<"Module ( "<<moduleName<<" )"<<endl;
    EV<<"Length = "<<this->SwitchingContQ.getLength()<<endl;
    EV<<"=============================="<<endl;

    for (currentIter; currentIter.end()==false;currentIter++)
    {
       SWC = (  SSSwitchingCont *) currentIter();

       EV<<"Job # "<<counter+1<<"-----------------"<<endl;
       EV<<"Start Holding Time  = "<<SWC->getStartHoldingTime()<<endl;
       EV<<"Switching State     = "<<SWC->getSwitchingState()<<endl;
       EV<<"Delay               = "<<SWC->getDelay()<<endl;
       EV<<"Release Time        = "<<SWC->getReleaseTime()<<endl;
       EV<<"Target Module       = "<<SWC->getTargetModule()<<endl;
       EV<<"Target Module ID    = "<<SWC->getTargetModuleID()<<endl;
       counter++;
    }

}
} /* namespace queueing */


